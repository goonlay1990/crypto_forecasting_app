{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b4ae2e1-89dc-4822-a3a6-5280508cab5a",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "# ============================================================\n",
    "# Streamlit App: BTC-USD OLS (AR) vs ARIMA - 2 Years Daily\n",
    "# ============================================================\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from itertools import product\n",
    "from statsmodels.tsa.arima.model import ARIMA\n",
    "from sklearn.metrics import mean_squared_error\n",
    "import statsmodels.api as sm  # for OLS\n",
    "\n",
    "# -----------------------------\n",
    "# Page setup (matches your style)\n",
    "# -----------------------------\n",
    "st.set_page_config(page_title=\"Crypto Forecast: OLS vs ARIMA\", layout=\"wide\")\n",
    "st.markdown(\"<style>.main {padding-top: 0px;}</style>\", unsafe_allow_html=True)\n",
    "st.markdown(\"<h1 style='text-align:center;margin-top:-10px;'>ARIMA & OLS Forecasting Model</h1>\", unsafe_allow_html=True)\n",
    "\n",
    "# -----------------------------\n",
    "# Sidebar controls\n",
    "# -----------------------------\n",
    "st.sidebar.header(\"Model Parameters\")\n",
    "symbol = st.sidebar.text_input(\"Cryptocurrency Symbol\", \"BTC-USD\")\n",
    "period = st.sidebar.selectbox(\"Data Period\", options=[\"6mo\", \"1y\", \"2y\", \"5y\"], index=2)\n",
    "interval = st.sidebar.selectbox(\"Interval\", options=[\"1d\"], index=0)\n",
    "prediction_ahead = st.sidebar.number_input(\"Prediction Days Ahead\", min_value=1, max_value=90, value=30, step=1)\n",
    "\n",
    "st.sidebar.markdown(\"---\")\n",
    "model_choice = st.sidebar.radio(\"Select Model\", [\"ARIMA\", \"OLS (AR via OLS)\"], index=1)\n",
    "\n",
    "st.sidebar.markdown(\"---\")\n",
    "train_ratio = st.sidebar.slider(\"Train Ratio (%)\", min_value=60, max_value=90, value=80, step=5)\n",
    "\n",
    "# Ranges (grid search)\n",
    "st.sidebar.subheader(\"Grid Search Ranges\")\n",
    "# ARIMA\n",
    "p_max_arima = st.sidebar.slider(\"ARIMA max p\", 0, 6, 4)\n",
    "d_max_arima = st.sidebar.slider(\"ARIMA max d\", 0, 3, 2)\n",
    "q_max_arima = st.sidebar.slider(\"ARIMA max q\", 0, 6, 4)\n",
    "# OLS AR(p)\n",
    "p_max_ols = st.sidebar.slider(\"OLS AR(p) max lags\", 1, 12, 6)\n",
    "\n",
    "run_button = st.sidebar.button(\"Predict\")\n",
    "\n",
    "# -----------------------------\n",
    "# Helpers\n",
    "# -----------------------------\n",
    "@st.cache_data(show_spinner=False, ttl=600)\n",
    "def download_crypto(sym, per, inter):\n",
    "    return yf.download(sym, period=per, interval=inter)\n",
    "\n",
    "def prepare_close(df: pd.DataFrame) -> pd.Series:\n",
    "    if df is None or df.empty:\n",
    "        raise ValueError(\"Download returned no data. Check symbol/connection.\")\n",
    "    s = df[['Close']].dropna()\n",
    "    s.index = pd.to_datetime(s.index)\n",
    "    s = s.asfreq('D').ffill()\n",
    "    return s['Close']\n",
    "\n",
    "def make_log_returns(close_series: pd.Series) -> pd.Series:\n",
    "    logp = np.log(close_series)\n",
    "    r = logp.diff().dropna()\n",
    "    return r\n",
    "\n",
    "# ---------- ARIMA ----------\n",
    "def evaluate_arima_model(train_series, test_series, arima_order):\n",
    "    try:\n",
    "        model = ARIMA(train_series, order=arima_order,\n",
    "                      enforce_stationarity=False, enforce_invertibility=False)\n",
    "        fit = model.fit()\n",
    "        preds = fit.forecast(steps=len(test_series))\n",
    "        mse = mean_squared_error(test_series, preds)\n",
    "        return mse, fit\n",
    "    except Exception:\n",
    "        return float('inf'), None\n",
    "\n",
    "def grid_search_arima(train_close, test_close, p_max, d_max, q_max):\n",
    "    results = []\n",
    "    for p, d, q in product(range(p_max+1), range(d_max+1), range(q_max+1)):\n",
    "        order = (p, d, q)\n",
    "        mse, fit = evaluate_arima_model(train_close, test_close, order)\n",
    "        results.append((order, mse, fit))\n",
    "    best_order, best_mse, best_model = min(results, key=lambda x: x[1])\n",
    "    return best_order, best_mse, best_model\n",
    "\n",
    "# ---------- OLS AR(p) ----------\n",
    "def fit_ols_ar(train_returns: pd.Series, p: int):\n",
    "    \"\"\"\n",
    "    Fit r_t = alpha + sum_{i=1..p} beta_i * r_{t-i} + e_t using OLS.\n",
    "    Returns params and training residuals.\n",
    "    \"\"\"\n",
    "    y = train_returns[p:]  # target from t=p onward\n",
    "    X = pd.concat([train_returns.shift(i) for i in range(1, p+1)], axis=1)[p:]\n",
    "    X.columns = [f\"lag{i}\" for i in range(1, p+1)]\n",
    "    X = sm.add_constant(X)  # add intercept\n",
    "    model = sm.OLS(y.values, X.values)\n",
    "    fit = model.fit()\n",
    "    params = fit.params  # [const, beta1, ..., betap]\n",
    "    return params, fit\n",
    "\n",
    "def recursive_forecast_returns(params, init_returns, steps):\n",
    "    \"\"\"\n",
    "    Recursively forecast returns using AR(p) params.\n",
    "    params: [const, beta1..betap]\n",
    "    init_returns: last p observed returns (np.array, order r_{t-1},...,r_{t-p})\n",
    "    \"\"\"\n",
    "    const = params[0]\n",
    "    betas = params[1:]\n",
    "    p = len(betas)\n",
    "    history = list(init_returns[:p])  # ensure list length p (order: r_{t-1},...,r_{t-p})\n",
    "    preds = []\n",
    "    for _ in range(steps):\n",
    "        # r_hat_t = const + sum beta_i * r_{t-i}\n",
    "        r_hat = const + np.dot(betas, np.array(history[:p]))\n",
    "        preds.append(r_hat)\n",
    "        # update history: prepend new r_hat, drop oldest\n",
    "        history = [r_hat] + history[:p-1]\n",
    "    return np.array(preds)\n",
    "\n",
    "def returns_to_prices(start_price, returns_array):\n",
    "    \"\"\"Convert a sequence of (log) returns to price path starting from start_price.\"\"\"\n",
    "    cum = np.cumsum(returns_array)  # cumulative log-return\n",
    "    prices = start_price * np.exp(cum)\n",
    "    return prices\n",
    "\n",
    "def grid_search_ols_ar(train_returns, test_returns, start_price_for_test, p_max):\n",
    "    \"\"\"\n",
    "    For each p=1..p_max, fit OLS AR(p) on train_returns.\n",
    "    Forecast len(test_returns) steps, convert to price path, compute MSE vs test closes.\n",
    "    Returns: best_p, best_mse, best_params, test_price_pred (array).\n",
    "    \"\"\"\n",
    "    results = []\n",
    "    best = None\n",
    "    # Need last p returns from train as initial state\n",
    "    for p in range(1, p_max+1):\n",
    "        if len(train_returns) <= p:\n",
    "            continue\n",
    "        params, fit = fit_ols_ar(train_returns, p)\n",
    "        init = train_returns.iloc[-p:][::-1].values  # order: r_{t-1}..r_{t-p}\n",
    "        pred_returns = recursive_forecast_returns(params, init, steps=len(test_returns))\n",
    "        pred_prices = returns_to_prices(start_price_for_test, pred_returns)\n",
    "        mse = mean_squared_error(test_prices:=np.exp(np.log(start_price_for_test) + np.cumsum(test_returns.values)), pred_prices)\n",
    "        # (Above: reconstruct test price path from returns to align lengths)\n",
    "        results.append((p, mse, params, pred_prices))\n",
    "    best = min(results, key=lambda x: x[1])\n",
    "    best_p, best_mse, best_params, best_test_pred_prices = best\n",
    "    return best_p, best_mse, best_params, best_test_pred_prices\n",
    "\n",
    "# -----------------------------\n",
    "# Run\n",
    "# -----------------------------\n",
    "if run_button:\n",
    "    try:\n",
    "        # 1) Download & prepare close\n",
    "        raw = download_crypto(symbol, period, interval)\n",
    "        close = prepare_close(raw)\n",
    "        st.success(f\"Data range: {close.index.min().date()} → {close.index.max().date()} | Obs: {len(close)}\")\n",
    "\n",
    "        # Plot full series\n",
    "        fig0, ax0 = plt.subplots(figsize=(12,4))\n",
    "        ax0.plot(close.index, close.values, label=f'{symbol} Close', color='steelblue')\n",
    "        ax0.set_title(f'{symbol} Close Price ({period})')\n",
    "        ax0.set_xlabel('Date'); ax0.set_ylabel('Price (USD)')\n",
    "        ax0.legend(); fig0.tight_layout()\n",
    "        st.pyplot(fig0)\n",
    "\n",
    "        # 2) Train/Test split on close\n",
    "        train_size = int(len(close) * (train_ratio / 100))\n",
    "        train_close = close.iloc[:train_size]\n",
    "        test_close = close.iloc[train_size:]\n",
    "\n",
    "        # Common metric cards layout\n",
    "        _, mm1, mm2, _ = st.columns([1,2,2,1])\n",
    "        latest_close = float(close.iloc[-1])\n",
    "\n",
    "        if model_choice == \"ARIMA\":\n",
    "            # ---- ARIMA ----\n",
    "            with st.spinner(f\"Running ARIMA grid search p=0..{p_max_arima}, d=0..{d_max_arima}, q=0..{q_max_arima} ...\"):\n",
    "                best_order, best_mse, best_model = grid_search_arima(train_close, test_close,\n",
    "                                                                     p_max_arima, d_max_arima, q_max_arima)\n",
    "\n",
    "            st.subheader(\"Best ARIMA Model\")\n",
    "            st.write(f\"**ARIMA{best_order}** | Test MSE: **{best_mse:,.6f}**\")\n",
    "\n",
    "            # Predictions on test\n",
    "            test_pred = best_model.forecast(steps=len(test_close))\n",
    "\n",
    "            # Future forecast from full data\n",
    "            final_model = ARIMA(close, order=best_order,\n",
    "                                enforce_stationarity=False, enforce_invertibility=False).fit()\n",
    "            future_fc = final_model.forecast(steps=prediction_ahead)\n",
    "            future_index = pd.date_range(start=close.index[-1], periods=prediction_ahead+1, freq='D')[1:]\n",
    "            proj_price = float(future_fc.iloc[-1])\n",
    "\n",
    "            mm1.metric(\"Latest Close (USD)\", f\"{latest_close:,.2f}\")\n",
    "            mm2.metric(f\"Projected after {prediction_ahead} day(s)\", f\"{proj_price:,.2f}\",\n",
    "                       delta=f\"{proj_price - latest_close:,.2f}\")\n",
    "\n",
    "            # Plot train/test + future\n",
    "            st.subheader(\"ARIMA - Train/Test & Future Forecast\")\n",
    "            fig1, ax1 = plt.subplots(figsize=(14,5))\n",
    "            ax1.plot(close.index, close.values, color='steelblue', label='Actual')\n",
    "            ax1.axvline(close.index[train_size], color='gray', linestyle='--', label='Train/Test Split')\n",
    "            ax1.plot(train_close.index, train_close.values, color='green', label='Train Data')\n",
    "            ax1.plot(test_close.index, test_close.values, color='orange', label='Test Data')\n",
    "            ax1.plot(test_close.index, test_pred.values, color='red', label=f'ARIMA{best_order} Predictions')\n",
    "            ax1.plot(future_index, future_fc.values, color='crimson', label=f'{prediction_ahead}-Day Forecast')\n",
    "            ax1.set_xlabel('Date'); ax1.set_ylabel('Price (USD)')\n",
    "            ax1.set_title(f'{symbol} ARIMA{best_order} Predictions')\n",
    "            ax1.legend(); fig1.tight_layout()\n",
    "            st.pyplot(fig1)\n",
    "\n",
    "            # Summary + CSV\n",
    "            with st.expander(\"Model summary (statsmodels)\"):\n",
    "                st.text(final_model.summary())\n",
    "            forecast_df = pd.DataFrame({\"date\": future_index, \"forecast\": future_fc.values})\n",
    "            st.download_button(\"⬇️ Download Forecast CSV\", data=forecast_df.to_csv(index=False).encode('utf-8'),\n",
    "                               file_name=\"arima_forecast.csv\", mime=\"text/csv\")\n",
    "\n",
    "        else:\n",
    "            # ---- OLS (AR via OLS on log returns) ----\n",
    "            st.subheader(\"OLS (AR(p) on log-returns)\")\n",
    "            returns = make_log_returns(close)\n",
    "            train_returns = returns.iloc[:train_size-1]  # -1 because returns are one shorter than price\n",
    "            test_returns = returns.iloc[train_size-1:]   # aligns with test_close starting point\n",
    "            start_price_for_test = float(train_close.iloc[-1])  # base to build price path\n",
    "\n",
    "            with st.spinner(f\"Running OLS AR(p) grid search p=1..{p_max_ols} ...\"):\n",
    "                best_p, best_mse, best_params, best_test_pred_prices = grid_search_ols_ar(\n",
    "                    train_returns, test_returns, start_price_for_test, p_max_ols\n",
    "                )\n",
    "\n",
    "            st.write(f\"**Best AR(p) with OLS:** p = {best_p} | Test MSE: **{best_mse:,.6f}**\")\n",
    "\n",
    "            # Future forecast from full returns\n",
    "            # Refit on full returns with best_p\n",
    "            params_full, fit_full = fit_ols_ar(returns, best_p)\n",
    "            init_full = returns.iloc[-best_p:][::-1].values  # r_{t-1}..r_{t-p}\n",
    "            future_returns = recursive_forecast_returns(params_full, init_full, steps=prediction_ahead)\n",
    "            future_prices = returns_to_prices(start_price=float(close.iloc[-1]), returns_array=future_returns)\n",
    "            future_index = pd.date_range(start=close.index[-1], periods=prediction_ahead+1, freq='D')[1:]\n",
    "            proj_price = float(future_prices[-1])\n",
    "\n",
    "            mm1.metric(\"Latest Close (USD)\", f\"{latest_close:,.2f}\")\n",
    "            mm2.metric(f\"Projected after {prediction_ahead} day(s)\", f\"{proj_price:,.2f}\",\n",
    "                       delta=f\"{proj_price - latest_close:,.2f}\")\n",
    "\n",
    "            # Plot train/test + OLS predictions and future\n",
    "            st.subheader(\"OLS AR(p) - Train/Test & Future Forecast\")\n",
    "            fig2, ax2 = plt.subplots(figsize=(14,5))\n",
    "            ax2.plot(close.index, close.values, color='steelblue', label='Actual')\n",
    "            ax2.axvline(close.index[train_size], color='gray', linestyle='--', label='Train/Test Split')\n",
    "            ax2.plot(train_close.index, train_close.values, color='green', label='Train Data')\n",
    "            ax2.plot(test_close.index, test_close.values, color='orange', label='Test Data')\n",
    "            ax2.plot(test_close.index, best_test_pred_prices, color='red', label=f'OLS AR({best_p}) Predictions')\n",
    "            ax2.plot(future_index, future_prices, color='crimson', label=f'{prediction_ahead}-Day Forecast')\n",
    "            ax2.set_xlabel('Date'); ax2.set_ylabel('Price (USD)')\n",
    "            ax2.set_title(f'{symbol} OLS AR({best_p}) Predictions')\n",
    "            ax2.legend(); fig2.tight_layout()\n",
    "            st.pyplot(fig2)\n",
    "\n",
    "            # Coefficients table + CSV\n",
    "            coef_df = pd.DataFrame({\"parameter\": [\"const\"] + [f\"lag{i}\" for i in range(1, best_p+1)],\n",
    "                                    \"value\": params_full})\n",
    "            st.markdown(\"**OLS Coefficients**\")\n",
    "            st.dataframe(coef_df, use_container_width=True)\n",
    "\n",
    "            forecast_df = pd.DataFrame({\"date\": future_index, \"forecast\": future_prices})\n",
    "            st.download_button(\"⬇️ Download Forecast CSV\", data=forecast_df.to_csv(index=False).encode('utf-8'),\n",
    "                               file_name=\"ols_ar_forecast.csv\", mime=\"text/csv\")\n",
    "\n",
    "    except Exception as e:\n",
    "        st.error(f\"Error: {e}\")\n",
    "\n",
    "else:\n",
    "   \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
